<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    function Star(uname, age) {
      this.uname = uname
      this.age = age
      // this.sing = function() {
      //   console.log('我会唱歌');
      // }
    }
    Star.prototype.sing = function () {
      // 构造函数的原型对象里面追加共享方法
      console.log('我会唱歌');
    }
    var ldh = new Star('刘德华', 18)
    var zxy = new Star('张学友', 19)
    ldh.sing()
    console.log(ldh) // 对象身上系统自己添加一个 __proto__ 指向构造函数的原型对象 prototyop
    console.log(ldh.__proto__ === Star.prototype)
    // 方法查找规则：首先先看看ldh对象上是否有 sing 方法，如果有就执行这个对象上的 sing
    // 如果没有sing 这个方法，因为有 __proto__ 的存在，就去构造函数原型对象 prototype 身上去寻找 sing 这个方法

    /* 
      对象都会有一个属性 __proto__ 指向构造函数的prototype原型对象，之所以对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在
      - __proto__ 对象原型和原型对象 prototype 是等价的
      - __proto__ 对象原型的意义就在于为对象的查找机制提供一个方向，或者说是一条路线，但是它是一个非标准书香，因此在实际开发中，不可以使用这个属性，它只是内部指向 原型对象prototype
    */
  </script>
</body>

</html>